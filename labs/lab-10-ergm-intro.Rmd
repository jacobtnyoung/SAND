---
title: "Lab 10 - Introduction to Exponential Random Graph Models (ERGMs) in R"
date: "CRJ 605 Statistical Analysis of Networks"
output: 
  html_document:
    df_print: paged
    theme: lumen
    highlight: haddock
    toc: yes
    toc_float: yes
    code_fold: show
    self_contained: true
---

```{r,echo=FALSE,eval=TRUE,message=FALSE,warning=FALSE}

library( devtools )
library( network )
library( sna )
library( UserNetR )

```

<style>
body {
text-align: left}
</style>

```{r, echo=FALSE}

# set the defaults for the codechunks
knitr::opts_chunk$set( eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE )

```

```{r,echo=FALSE}

# libraries needed

library( sna )     # for sna functions
library( network ) # for working with network objects
library( ergm )    # for working with ergms

```

----

<br>

In the [Introduction to Exponential Random Graph Models (ERGMs) lecture](../lectures/lecture-08-ergm.pdf) you were introduced to several examples of models from the exponential family of random graphs. This lab provides an introduction to ERGMs in R using the `ergm` package. We will work through different dependence specifications of the model reviewed in the lecture (e.g. dyadic independence) and show how to incorporate node level attributes into the model.

<br>

# **Modeling Friendship in the PINS *Get Along With* and  *Power/Influence* Networks**  

The [*Prison Inmate Networks Study (PINS)*](https://cjrc.la.psu.edu/research/) examines the social networks of prison inmates in a state correctional institution. The study was unique in that it was the first in nearly a century to collection sociometric data in a prison. The researchers collected data on several types of networks. There are two we want to look at here:

  * The *get along with network* was created by asking individuals whom they "get along with" on the unit. We can think of this as "friends" in a prison setting. (People don't really have "friends" in prison, but there are people they "get along with")
  
  * The *power and influence network* was created by asking individuals whom they believed was "powerful and influential" on the unit.

Let's examine the degree centrality scores for both of these networks. These data are available in the [SNA Textbook](https://jacobtnyoung.github.io/sna-textbook/index.html) [data]() folder.

<br>

## *Get Along With* Network (Undirected Network)

For the *get along with* network, individuals could have asymmetric nominations. That is, *i* could nominate *j* and *j* didn't necessarily nominate *i*. But, we are going to **symmetrize** the network by only taking ties for which ***both*** *i* and *j* indicated that the get along with the other person. This will give us an undirected network.
 
```{r}

# load the libraries we need
library( sna )
library( network )

# set the location for the file
loc <- "https://github.com/jacobtnyoung/sna-textbook/raw/main/data/data-PINS-getalong-w1-adj.csv"

# read in the .csv file
gaMat <- as.matrix(
  read.csv( 
    loc,
    as.is = TRUE,
    header = TRUE,
    row.names = 1 
    )
  )

# use the symmetrize() function to create an undirected matrix
gaMatU <- symmetrize( gaMat, rule = "strong" )

# create the network object
gaNetU <- as.network( gaMatU, directed = FALSE )

```

<br>


```{r, fig.show="hide"}

# Set the coordinates
set.seed( 605 )
coords <- gplot( gaNetU )

```


```{r, echo=FALSE, fig.align="center"}

gplot( 
  gaNetU, 
  gmode = "graph",
  edge.col="grey40", 
  vertex.col="#c78c71",
  coord = coords,
  main = "PINS Get\n Along With Network (Undirected)"  
  )

```

*Think about the structure here. What do you notice?*  

*How might we go about incorporating this information into a model of the network?*  

<br>

Before we get going, let's define some graphical objects we will use.

```{r}

# define the number of nodes
g <- dim( gaMatU )[1]

# define the number of edges
l <- sum( gaMatU )/2

# define the density
den <- l / ( g *( g - 1 ) / 2 ) 

den

```

*What is the interpretation of the density?*  

<br>

Recall that the exponential random graph model seeks to model the underlying processes that generated the observed network. Let's create a random graph with the same nodes, edges, and density as the `gaNetU` network and compare them by using the `rgraph()` function in the `sna` package:

```{r, message=FALSE}

?rgraph

# set the seed to reproduce these results
set.seed( 605 )

# generate the random graph
random.graph <- rgraph(
  g,                   # the number of nodes in the network
  1,                   # we want just 1 random graph 
  tprob = den,         # the density of the network 
  mode = "graph"       # it is undirected 
  )

# now coerce the random graph to a network object
random.net <- as.network( random.graph, directed = FALSE )

```

<br>

We can now compare our observed data with a graph that has the same density and the edges are randomly distributed over the nodes.

```{r}

# set the margins
op <- par( mfrow=c( 1,2 ), 
           mar=c( 0.1, 0.5, 2, 0.5 ) )

# set the seed
set.seed( 605 )

# create the first plot
gplot( 
  gaNetU, 
  gmode = "graph",
  edge.col="grey40", 
  vertex.col="#c78c71",
  coord = coords,
  main = "PINS Get\n Along With Network (Undirected)"
  )

# create the second plot
gplot( 
  random.net, 
  gmode = "graph",
  edge.col = "grey40", 
  vertex.col="#069e6e",
  main = "Random network"
  )

# use these options for the output plots
par( op )

```

*How is the Get Along With network different from the random network?*  

<br>

### **Adding Attributes (revisited)**

Recall that there is an attributes file that we can attach to these data. Let's load that and use these attributes in our plot.

```{r}

# define the attributes object
attrs <- read.csv( 
    "https://raw.githubusercontent.com/jacobtnyoung/sna-textbook/main/data/data-PINS-w1-age-race-attributes.csv",
    as.is = TRUE,
    header = TRUE 
    )

# assign the attributes to the network
gaNetU %v% "Age" <- attrs[,1]
gaNetU %v% "Race" <- attrs[,2]

```

Now that these are assigned as an attribute, we can reference them using the `%v%` operator. For example, let's look at the values for the `Race` attribute.

```{r}

# print out the values for each node
gaNetU %v% "Race"

# use the table() function to count each value
table( gaNetU %v% "Race" )

# let's recode the single 4 to a 1
race.recoded <- attrs[,2]
race.recoded[ race.recoded == 4 ] <- 1

# now assign the recoded value
gaNetU %v% "Race" <- race.recoded

```

Now, let's use the `Race` attribute and the `Age` attribute in a plot. We will color the nodes based on `Race` and size the nodes based on `Age`. Note that for `Age`, we are going to need to use the `rescale()` function.

```{r}

# create the colors for race
node.cols <- gaNetU %v% "Race"
node.cols[ gaNetU %v% "Race" == 1 ] <- "#eb105d"
node.cols[ gaNetU %v% "Race" == 2 ] <- "#5773fa"
node.cols[ gaNetU %v% "Race" == 3 ] <- "#37cf00"

# define the rescale function
rescale <- function( nchar, low, high ){
  min_d <- min( nchar )
  max_d <- max( nchar )
  rscl  <- ( ( high - low )*( nchar - min_d ) ) / ( max_d - min_d ) + low
  rscl
}

# now, plug our pieces into our plot
gplot( 
  gaNetU, 
  gmode = "graph",
  edge.col = "grey40", 
  vertex.col = node.cols,
  vertex.cex = rescale( gaNetU %v% "Age", 0.5, 2 ),
  coord = coords,
  main = "PINS Get\n Along With Network (Undirected)"
  )

# add a legend
legend( "topright", 
        legend=c( "White", "Black", "Hispanic" ), 
        col = unique( node.cols ), 
        pch = 19, 
        pt.cex=2
        )

```

*Think about the structure again. What do you notice about race or age?*  

*How might we go about incorporating this information into a model of the network?*  

<br>

# **Getting Started with the `ergm` Package and the `ergm()` Function**  

First things first, we need to install the `ergm` package and load the library of functions. 

```{r, eval=FALSE}

# clear the workspace
rm( list = ls() )

# install the ergm package
install.packages( "ergm" )

# load the ergm package
library( ergm )

# take a look at the functionality
help( package = "ergm" )

```

<br>

If you look at the `ergm()` function using `?ergm`, then you will see an extensive help file on the function.

<br>

## The `ergm()` Function

The `ergm()` function takes two arguments:  

* an object of class `network` (the dependent variable)  

* and some terms (i.e. network configurations)

Thus, the model form looks like this: `model <- ergm(network ~ term)`. Recall from the Introduction to ERGMs lecture that the general expression of the model is:  

$logit\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = \sum_{k=1}^\kappa \theta_k\delta_{z_k(y)}$  

As with logistic regression, the logit transformation can be used to re-express the equation as the conditional probability of a tie:

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(\theta_1\delta_{z_1(y)+\theta_2\delta_{z_2}(y)...})$   

Here, the coefficients are expressed as the conditional log-odds of a single actor pair. That is, how likely we are to see a tie between *i* and *j*, given some model terms. *So, what are those model terms or **network configurations**?*  

We can view all of the network statistics that have been programmed by using the `?ergm.terms` command. You can also use the `(vignette("ergm-term-crossRef"))` command to show you a bit more info about the model terms.  

## **Edge independence (Bernoulii/Simple Random graphs)**  

The ERGM expresses the probability of observing a tie between nodes *i* and *j* given some terms (i.e. network configurations). The edge independence model of Erdos and Renyi (1959) uses a single term, the number of edges in the graph, to represent the probability of a tie:   

$P(Y=y)=\Bigg(\frac{1}{c}\Bigg) exp \big\{\theta L(y) \big\}$  

In the `ergm()` function, this term is `edges`. Let's take a look at this model:

```{r, message=FALSE}

?edges

# run the model
edge.indep.gaNetU <- ergm( gaNetU ~ edges ) 

# check out the summary
summary( edge.indep.gaNetU )

# note that the ergm() function creates an object of class ergm
class( edge.indep.gaNetU )
names( edge.indep.gaNetU )

```

First, the summary shows the coefficent $\theta$ from the equation above. The value of `r round( edge.indep.gaNetU$coefficients[1], 2 )` indicates that the desnity of the network is below .5 or 50%. An `edges` term of 0 would represent 50% or 0.5 density. As we saw above, the density of the `gaNetU` network is `r round( den, 3 )`.   

In the general formulation of the ERGM, the $\delta$ represents the *change statistic*, or the change in the statistic of interest when an edge is added (i.e. $Y_{ij}$) goes from 0 to 1). The change statistic for the `edges` term is always 1, so we can think of the probability of a tie between *i* and *j* as the logit of the coefficients for the `edges` term. Specifically, we can use the calculation that is usual for a logistic regression to interpret the coefficient:  

$\frac{1}{1 + e^{-(\theta_1X_1)}}$

If we plug in the value of `r round( edge.indep.gaNetU$coefficients[1], 2 )` that is returned by the `ergm()` function, we get:  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(\theta_{edges} \times \delta_{edges})$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(-5.39 \times 1)$    

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = \frac{1}{1 + e^{-(-5.39 \times 1)}} = 0.005$    

*Does the value `r round(plogis(-5.39),3 )` look familiar?*  

The value of `r round( plogis( -5.39 ), 3 )` is returned by using the `plogis()` function. Use the `?plogis` command to examine the help file for this function.

<br>

```{r}

# we could write it out 
plogis( -5.39 * 1 )

# or, we could pull from the model object
plogis( edge.indep.gaNetU$coefficients[1] * 1 )

```

*So what is this?* Recall that the ERGM expresses the probability of observing a tie between nodes *i* and *j* given some terms (i.e. network configurations). The edge independence model of Erdos and Renyi (1959) uses a single term, the number of edges in the graph, to represent the probability of a tie. So, here we are saying that the probability of a tie between two nodes is `r plogis( edge.indep.gaNetU$coefficients[1] * 1 )`. 

*Does that help us understand the structure in the network?* 

Sort of, but it tells us about as much as the random network we plotted above. We can extend this model to include characteristics of nodes.

<br>

## **Adding Nodal Covariates**  

So far, we have assumed that the probability of a tie is independent of any nodal attribute. We could relax this assumption and test two hypotheses:  

* Nodes differ in their degree based on their race.  

* Nodes that are the same race are more likely to share ties (i.e. *homophily*).

<br>

We can test these hypotheses using the `nodefactor` (for categorical attributes [for continuous attributes use `nodecov`]) and `nodematch` (for categorical attributes [for continuous attributes use `absdiff`]) terms. Take a look at the description of the term `nodefactor` term using `?nodefactor`.

<br>

### **Testing the Degree Effects of Race/Ethnicity**

Why make these hypotheses? First, let's take a look at the degree distribution for race. Let's compare the mean degree for each group:

```{r}

# mean degree for white
round( mean( degree( gaNetU, gmode = "graph", cmode = "degree" )[gaNetU %v% "Race" == 1] ), 2 )

# mean degree for black
round( mean( degree( gaNetU, gmode = "graph", cmode = "degree" )[gaNetU %v% "Race" == 2] ), 2 )

# mean degree for hispanic
round( mean( degree( gaNetU, gmode = "graph", cmode = "degree" )[gaNetU %v% "Race" == 3] ), 2 )

```

*Now, how are the mean degrees different for each racial group?* 

*Are these differences due to random variation?*

```{r}

# let's add the nodefactor term for race to our model
race.gaNetU <- ergm( 
  gaNetU ~ edges 
  + nodefactor( "Race" )
  ) 

summary( race.gaNetU )

```

Note that the term adds one network statistic to the model for each categorical value of the variable we have passed. The first category is excluded as the reference category. The first category is white (which is coded as 1), so it is automatically excluded and serves as the referent category. This can be overriden if we want to.

For the `nodefactor` term, positive values indicate that a node with that particular value of the attribute is *more likely* to have an edge, relative to the referent category. Alternativley, a negative value indicates that a node with that particular value of the attribute is *less likely* to have an edge, relative to the referent category. 

*What does the model tell us?*

<br>

Let's look at this for our example. Looking at the table we see:  

* the term `r names( race.gaNetU$coefficients )[2]` has a value of `r round( race.gaNetU$coefficients[2], 2 )`, but is not significantly different from zero at the *p<0.5* level. Thus, the difference in degree for white and black that we observed above is consistent with random variation.  

* the term `r names( race.gaNetU$coefficients )[3]` has a value of `r round( race.gaNetU$coefficients[3], 2 )` and is  significantly different from zero at the *p<0.5* level. Thus, compared to whites, the probability of a tie between *i* and *j* is lower if either *i* or *j* are Hispanic.  

Recall that in the general formulation of the ERGM, the $\delta$ represents the *change statistic*, or the change in the statistic of interest when an edge is added (i.e. $Y_{ij}$) goes from 0 to 1). The change statistic for the `nodefactor` term is different from the `edges` term we saw above. If the predictor is categorical, the value of the change statistic is 0, 1 or 2. Specifically:  

* If neither of the nodes have the characteristic of interest, the change statistic is 0.  

* A value of 1 indicates that *one* of the nodes in the dyad has the characteristic.  

* A value of 2 indicates that *both* of the nodes in the dyad have the characteristic.

Again, let's use the calculation that is usual for a logistic regression to interpret the coefficient:  

$\frac{1}{1 + e^{-(\theta_1X_1)}}$

Using the coefficient of `r round( race.gaNetU$coefficients[3], 2 )`, the predicted probability of a tie between *i* and *j* if they are **both** Hispanic is:

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(\theta_{edges} \times \delta_{edges} + \theta_{race} \times \delta_{race})$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic((-4.91 \times 1) + (-1.14 \times 2))$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(-4.91 + -2.28)$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(-7.19) = 0.0008$  

The value of `r round( plogis( -7.19 ), 4 )` is returned by using the command `plogis()`. We can see this by adding the equation elements to the `plogis()` function.

```{r}

plogis(
    race.gaNetU$coefficients[1]*1  # the edges term
  + race.gaNetU$coefficients[3]*2  # the nodefactor hispanic term
  )

# rounded
round( plogis( race.gaNetU$coefficients[1]*1 + race.gaNetU$coefficients[3]*2 ), 4 )

```

What is the predicted probability of a tie between *i* and *j* if only **one** is Hispanic?:

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(\theta_{edges} \times \delta_{edges} + \theta_{race} \times \delta_{race})$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic((-4.91 \times 1) + (-1.14 \times 1))$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(-4.91 + -1.14)$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(-6.05) = 0.002$  

The value of `r round( plogis( -6.05 ), 3 )` is returned by using the command `plogis()`. We can see this by adding the equation elements to the `plogis()` function.

```{r}

plogis(
    race.gaNetU$coefficients[1]*1
  + race.gaNetU$coefficients[3]*1  # NOTE: we are only multiplying by 1!!!
  )

# rounded
round( plogis( race.gaNetU$coefficients[1]*1 + race.gaNetU$coefficients[3]*1 ), 3 )

```

Note that this is quite a change from having **two** nodes who are *Hispanic*. This difference in the probability of a tie shows you that *Hispanics* are less connected to the network, relative to other race/ethnicities.  

*Finally, what is the predicted probability of a tie between i and j if only both are White?*

<br>

### **Testing Homophily on Race/Ethnicity**

!!!!HERE
!!!!HERE
!!!!HERE
!!!!HERE
!!!!HERE





Now let's look at a different hypothesis: Nodes with the same role designation are more likely to share ties than nodes that are not in the same role designation (i.e. *homophily*). We can test this using the `nodematch` term. But first, let's look at the *mixing* between each category value with the `mixingmatrix` function. This function returns homophilous ties in the diagonal and heterophilous ties in the off-diagonal.

```{r,echo=TRUE,eval=TRUE,message=FALSE,include=TRUE}
?mixingmatrix

# Look at the attribute values.
mixingmatrix(Bali,"role")
```

*Looking at the mixing matrix for **role**, what patterns do you see?*  


```{r,echo=TRUE,eval=TRUE,message=FALSE,include=TRUE}
?nodematch

# Homophily.
role2.Bali <- ergm(Bali ~ edges + nodematch("role")) 
summary(role2.Bali)
```

Note that the term adds one network statistic to the model for the variable. For the `nodematch` term, positive values indicate that for a pair of nodes with the **same** attribute value, an edge is *more likely*. Alternativley, a negative value indicats that for a pair of nodes with the **same** attribute value, an edge is *less likely*. Thus, positive coefficients indicate the presence of **homophily** and negative coefficients indicate the presense of **heterophily**.

Let's work through our example to see the interpretation of the coefficient. Looking at the table we see:  

* the term `nodematch.role` has a value of `2.3844`, indicating that ties are more likely among nodes with the same value for the variable **role**.  

Recall that in the general formulation of the ERGM, the $\delta$ represents the *change statistic*, or the change in the statistic of interest when an edge is added (i.e. $Y_{ij}$) goes from 0 to 1). The change statistic for the `nodematch` term is similar to the `edges` term we saw above. If the predictor is categorical, the value of the change statistic is 0 or 1. Specifically:  

* If *i* and *j* have the same value for a categorical covariate the change statistic is 1.  

* If *i* and *j* **do not** have the same value for a categorical covariate the change statistic is 0.  

Again, let's use the calculation that is usual for a logistic regression to interpret the coefficient:  

$\frac{1}{1 + e^{-(\theta_1X_1)}}$

Using the coefficient of 2.3844, the predicted probability of an edge between nodes with the **same** role designation is:

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic((\theta_{edges} \times \delta_{edges}( + (\theta_{role.homophily} \times \delta_{role.homophily}))$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(-0.4873 \times 1 + 2.3844 \times 1)$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(-0.4873 + 2.3844)$  

$\Bigg(P \Bigg(Y_{ij}=1 \> | \> n \> actors, Y_{ij}^C\Bigg) \Bigg) = logistic(1.8971) = 0.869 $  

The value of 0.869 is returned by using the command `plogis()`.  

Note that this is a fairly large effect. That is, based on the model, nodes with the same role have an 86% chance of being connected.

```{r,echo=TRUE,eval=TRUE,message=FALSE,include=TRUE}
plogis(role2.Bali$coef[1]*1 + role2.Bali$coef[2]*1)
```


```{r,echo=TRUE,eval=TRUE,message=FALSE,include=TRUE}
?nodematch

#Note that there are two forms of homophily: uniform homophily and differential homophily.

# Uniform homophily.
role2.Bali <- ergm(Bali ~ edges + nodematch("role")) 
summary(role2.Bali)

# Differential homophily.
role3.Bali <- ergm(Bali ~ edges + nodematch("role", diff=TRUE)) # by adding the diff=TRUE argument, we ask for a statistic for each value of the attribute.
summary(role3.Bali)

# Yikes, very unstable estimates.
```


!!!HERE: need to update below with the correct syntax from lab 9 for the bottom of the page


***  

#### ***Questions?***


<br>

##### ***Please*** report any needed corrections to the [Issues](https://github.com/jacobtnyoung/SAND/issues/new) page. Thanks!

<br>
<br>


###### ***Last updated `r format(Sys.time(), '%d %B, %Y')`***