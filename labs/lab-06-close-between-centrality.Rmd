---
title: "Lab 05-Closeness & Betweenness Centrality/Centralization"
date: "CRJ 605 Statistical Analysis of Networks"
output: 
  html_document:
    df_print: paged
    theme: lumen
    highlight: haddock
    toc: yes
    toc_float: yes
    code_fold: show
    self_contained: true
---

----

*This lab examines closeness centrality and betweenness centrality/centralization using the `closeness()`, `betweenness()`, and `centralization()` functions in the `sna` package.*


```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}

# Load the libraries you need to render the .html file

library( sna )
library( devtools ) # for the install_github() function
# install_github( "DougLuke/UserNetR" ) # use this if UserNetR is not installed
library( UserNetR )
library( network )

```

### **Closeness Centrality (Undirected Binary Graphs)**  

How *close* is a node to other nodes?  

In an undirected binary graph, **closeness centrality** measures how near a node is to the other nodes in the network. This is based on the inverse of the distance of each actor to every other actor.  

Terminology:  

  + The **distance**, $d(n_i,n_j)$, is the length of the path between *i* and *j*.  
  
    + For example, suppose Sally is friends with Tom, Ulrica, and Violet; Violet is friends with Tom and Walter. What are the *paths* from Violet to Ulrica? Walter from Ulrica?  
  
  
  + A **geodesic** is the shortest path between two nodes. What is the *shortest path* (i.e. geodesic) from Violet to Ulrica?  

<br>

**Closeness** centrality is calculated as: 

$$C_C(n_i) = [\sum\limits_{j=1}^g d(n_i,n_j)]^{-1}$$

or 

$$\frac{1}{[\sum\limits_{j=1}^g d(n_i,n_j)]}$$ 
Here is what the equation is doing:  

  + first identify the distances between *i* and *j* (i.e. $d(n_i,n_j)$) and sum them.
  
  + Note that $\sum\limits_{j=1}^g$ is indicating that for *i*, we want to sum over all the *j*s in the graph, *g*. 
  
  + then take the inverse of this quantity.  

<br>

We can manually calculate the distance matrix using the `geodist()` function in the `sna` package.  

Let's take a look:

```{r,echo=TRUE,eval=TRUE,message=FALSE}

# clear the workspace
rm( list = ls() )

# load the sna library
library( sna )

# now, take a look at the geodist() function
?geodist

```

Let's go ahead and set up a simple matrix and examine the geodesics for that matrix.

```{r,echo=TRUE,eval=TRUE,message=FALSE}

# set up the matrix
u.mat <- rbind(
  c( 0,1,0,0,0 ),
  c( 1,0,1,0,0 ),
  c( 0,1,0,1,1 ),
  c( 0,0,1,0,1 ),
  c( 0,0,1,1,0 ))

# now set the names
mat.names <- c( "Jen","Tom","Bob","Leaf","Jim" )
rownames( u.mat ) <- mat.names
colnames( u.mat ) <- mat.names

# let's look at what the geodist() function creates
u.mat.geodist <- geodist( u.mat )
class( u.mat.geodist )
u.mat.geodist

```  

We can see that the function creates an object of class `list`. In the object, there are two arrays, `$counts` and `$gdist`. To get the geodesic distances, we use the `$` sign to select a single piece from the list:

```{r,echo=TRUE,eval=TRUE,message=FALSE}

# print out the distances
u.mat.geodist$gdist

# if we take the row sum of this object, we get the distances
distance <- rowSums( u.mat.geodist$gdist )
distance

```

<br>

Now, let's plot the graph so we can visualize what the distance score is showing. To make it easier to see, let's add the centrality info to the labels and size the nodes by centrality. That will make it easier to visualize.

```{r,echo=TRUE,eval=TRUE,message=FALSE}

# create a vector of labels that combines the name with the distances
# use the paste() function to put characters and numbers together
names.dist <- paste( 
  mat.names, # the names of the vertices
  ", ", # add a comma to separate name from degree
  round( distance, 0 ), # add the rounded distance
  sep = "" ) # remove the space between the two inputs 

# change the margins using the mar= argument
par( mar=c( 0.1, 0.5, 1, 0.1 ) )

# set the seed to reproduce the same layout
set.seed( 605 )

# render the plot
gplot( 
  u.mat,
  gmode = "graph",
  label = names.dist,
  label.cex = 0.6,
  vertex.col = "lightblue"
  )

```  

In this plot, we see that **Jen** has a distance score of *9*. To see how we get that score, let's do the calculation:  

  + recall that $d(n_i,n_j)$ is the length of the path from *i* to *j*
  
    + Jen -> Tom ($d(Jen,Tom)$) is 1
  
    + Jen -> Bob ($d(Jen,Bob)$) is 2
  
    + Jen -> Leaf  ($d(Jen,Leaf)$) and Jen -> Jim ($d(Jen,Jim)$) are both 3
  
    + So that is $\sum\limits_{Jen}^g d(Jen,Tom/Bob/Leaf/Jim) = 1+2+3+3=9$.


<br>

To get the closeness centrality score, we divide that quantity by 1.

```{r,echo=TRUE,eval=TRUE,message=FALSE}

# take the reciprocal
close.cent <- 1 / rowSums( u.mat.geodist$gdist )
close.cent

# we can calculate the standardized closeness centrality by multiplying by g-1
g <- dim( u.mat )[1]
close.cent.s <- ( g-1 ) * close.cent
close.cent.s

# put it all together in a table
dist.close.table <- round( rbind( distance, close.cent, close.cent.s ), 2 )
round( dist.close.table, 2 )
rownames( dist.close.table ) <- c( "distance", "closeness", "stand.close" )
colnames( dist.close.table ) <- mat.names
dist.close.table

```

<br>

Now, let's take a look at this info in a series of plots. To render these, let's use a `for` loop:

<br>

```{r,echo=TRUE,eval=TRUE,message=FALSE}

names.close <- paste( 
  mat.names, # the names of the vertices
  ", ", # add a comma to separate name from degree
  round( close.cent, 2 ), # add the rounded closeness centrality score
  sep = "" ) # remove the space between the two inputs 

names.s.close <- paste( 
  mat.names, # the names of the vertices
  ", ", # add a comma to separate name from degree
  round( close.cent.s, 2 ), # add the rounded closeness centrality score
  sep = "" ) # remove the space between the two inputs 

# create the inputs for the loop
titles <- c( "Distance", "Closeness", "Standardized Closeness")
cols <- c( "lightblue", "lightgreen", "orange" )
names <- rbind( names.dist, names.close, names.s.close )

# change the margins using the mar= argument
par( 
  mfrow=c( 2,2 ),
  mar=c( 0.1, 0.5, 1, 0.1 ) 
  )

for( i in 1:3 ){
  
  # set the seed
  set.seed( 605 )

  # render the plot
  gplot( 
  u.mat,
  gmode = "graph",
  label = names[i,],
  label.cex = 0.6,
  vertex.col = cols[i],
  main = titles[i]
  )

}

```  

#### **Using the `sna` Package**  

Alternatively, we could just use the `closeness()` function in the `sna` package. First, take a look at the function using `?closeness`. Note that the standardized closeness centrality is reported by default. If we want the unstandardized closeness, we can just divide the result returned by `closeness()` by *g-1*.

```{r,echo=TRUE,eval=TRUE,message=FALSE}

# note the gmode= argument
?closeness

# standardized
closeness( u.mat,gmode="graph")

# raw
closeness( u.mat,gmode="graph" ) / ( g-1 )

```

<br>

### **Betweenness Centrality (Undirected Binary Graphs)**  

We have seen how centrality can be conceptualized as having a high number of ties (i.e. *degree* centrality) or being close to others in the network (i.e. *closeness* centrality). We can also conceptualize centrality as a node that lies on a particular path between other nodes. *Betweenness* centrality is based on the number of shortest paths between *j* and *k* that actor *i* resides on.  

Betweenness centrality is calculated as: 

$$C_B(n_i) = \sum\limits_{j<k} g_{jk}(n_i) / g_{jk}$$  

Where $g_{jk}$ represents the number of geodesics linking *j* to *k* and $g_{jk}(n_i)$ is the number of geodesics linking *j* and *k* that contain *i*. So, betweenness centrality is the ratio of the geodesics between *j* and *k* that contain *i* to the geodesics between *j* and *k* that **do not** contain *i*.  

The *standardized* betweenness centrality score is calculated by: 

$$C'_B(n_i) = \frac{\sum\limits_{j<k} g_{jk}(n_i) / g_{jk}}{[(g-1)(g-2)/2]}$$

The difference here is that we are dividing by $g_{jk}}{[(g-1)(g-2)/2$ which is the number of pairs of actors not including *i*.  

<br>

We can calculate betweenness centrality using the `betweenness()` function in the `sna` package:  

```{r,echo=TRUE,eval=TRUE,message=FALSE}

?betweenness

# raw
betweenness( u.mat,gmode="graph" )

# standardized
betweenness( u.mat,gmode="graph" ) / ( ( ( g-1 ) * ( g-2 ) ) / 2 )

```  

***  

### **Correlation between Centrality Measures**  

Centrality measures are not always perfectly correlated because they measure different concepts. Examining the correlation tells us something about what the overall graph structure looks like. Let's take a look at the correlation between degree, closeness, and betweenness centrality.  

```{r,echo=TRUE,eval=TRUE,message=FALSE}

cent.u.mat <- data.frame(
    deg.cent = degree(u.mat,gmode="graph"),
    close.cent = closeness(u.mat,gmode="graph"),
    between.cent = betweenness(u.mat,gmode="graph")
)

# print the correlation matrix.
cor(cent.u.mat)

# look at each individually.
cor(cent.u.mat)["deg.cent","close.cent"] # very highly correlated.
cor(cent.u.mat)["deg.cent","between.cent"] # less so, meaning that there are some with higher degree and not necessarily higher betweenness.
cor(cent.u.mat)["close.cent","between.cent"] # pretty highly correlated.

```

We can visualize this by creating three plots. In these plots, the nodes are sized in proportion to their centrality score and the labels indicate this value.  

```{r,echo=TRUE, eval=TRUE, message=FALSE}
par(mfrow = c(2,2), oma = c(5,4,0,0) + 0.1, mar = c(0,0,1,1) + 0.1)
set.seed(1)
gplot(u.mat, gmode="graph", vertex.cex=degree(u.mat,gmode="graph"), label = round(degree(u.mat,gmode="graph"),2), label.pos = 3, vertex.col= "red", main="Degree Centrality")
set.seed(1)
gplot(u.mat, gmode = "graph", vertex.cex=closeness(u.mat,gmode="graph"), label = round(closeness(u.mat,gmode="graph"),2), label.pos = 3,vertex.col= "blue", main="Closeness Centrality")
set.seed(1)
gplot(u.mat, gmode = "graph", vertex.cex=betweenness(u.mat,gmode="graph"), label=round(betweenness(u.mat,gmode="graph"),2) , label.pos =3,vertex.col= "green", main="Betweenness Centrality")
par(mfrow=c(1,1)) # return plotting pane to have 1 panel.
```

***  

### **Centralization**

#### **Closeness Centralization**  
We can also summarize the entire network, in terms of how close nodes are to each other. *Group closeness centralization* tells us how much variation there is in the closeness scores. As with degree centrality, this measure is bound between 0 and 1 where a value of 0 indicates complete uniformity across nodes in there centralization scores and a value of 1 indicates that one node has the highest possible centrality score, and all others are at the minimum.  

This is calculated as: $C_C = \frac{\sum\limits_{i=1}^g[C'_C(n^*)-C'_C(n_i)]}{[(g-2)(g-1)]/(2g-3)}$.  

Where $C'_C(n^*)$ is the maximum or largest standarized closeness centrality score. For a more elaborate discussion of this equation, see Wasserman & Faust (1994: 191-192).  To calculate the group closeness centrality, we can use the `centralization()` function in `sna` and specify `closeness` in the `FUN` argument.

```{r,echo=TRUE,eval=TRUE,message=FALSE}
?centralization
centralization(u.mat,closeness,mode="graph")
```

#### **Betweenness Centralization**    

We can also summarize the entire network, in terms of how close nodes are to each other. *Group betweenness centralization* tells us how much variation there is in the betweenness scores.  

This is calculated as: 

$$C_B = \frac{\sum\limits_{i=1}^g[C'_B(n^*)-C'_B(n_i)]}{(g-1)}$$  

Where $C'_B(n^*)$ is the maximum or largest standardized betweenness centrality score. To calculate the group betweenness centrality, we can use the `centralization()` function in `sna` and specify `betweenness` in the `FUN` argument.

```{r,echo=TRUE,eval=TRUE,message=FALSE}
?centralization
centralization(u.mat,betweenness,mode="graph")
```

***  

###**Closeness and Betweenness Centrality for Directed Graphs**  

```{r,echo=TRUE,eval=TRUE,message=FALSE}
# Build the objects.
d.mat <- rbind(c(0,1,0,0,0),c(0,0,1,0,0),c(0,0,0,1,1),c(0,0,1,0,1),c(0,0,1,1,0))
rownames(d.mat) <- c("Jen","Tom","Bob","Leaf","Jim")
colnames(d.mat) <- c("Jen","Tom","Bob","Leaf","Jim")
d.net <- network(d.mat, matrix.type = "adjacency", directed = TRUE)


### Closeness Centrality.

# Manually.
distances <- geodist(d.mat)
geodesics <- distances$gdist
geodesics[geodesics == Inf] <- 0 # code Inf values as zero.
1/rowSums(geodesics) #unstandardized closeness.
(1/rowSums(geodesics))*4 #standardized closeness.

# Or, using the closeness() function.
closeness(d.mat, gmode="digraph") #standardized closeness.
closeness(d.mat, gmode="digraph")/4 #unstandardized closeness.

# Group Closeness Centralization.
centralization(d.net,closeness,mode="digraph")
centralization(d.net,closeness,mode="digraph")


### Betweenness Centrality.

# using the betweenness() function.
betweenness(d.mat,gmode="digraph") #unstandardized.
betweenness(d.mat,gmode="digraph") / (((5-1)*(5-2))/2) # standardized.

# Group Betweenness Centralization.
centralization(d.mat,betweenness,mode="digraph") 
```

***  

### **Centrality in PINS Get Along With Network**  

The [*Prison Inmate Networks Study (PINS)*](https://cjrc.la.psu.edu/research/) examines the social networks of prison inmates in a state correctional institution. 
If you scroll through the [website](https://cjrc.la.psu.edu/research/), you will see that there are two edgelists available from the first wave of the study:  

  +  The *get along with network* measures the individuals that individuals indicated they "get along with" on the unit. 
  
  +. The *power and influence network* captures nominations made of individuals who were considered "powerful and influential" on the unit.  

We can examine the centrality scores by first building the *get along with* network from the edgelist on the website:
 
```{r,echo=TRUE,eval=TRUE,message=FALSE, figure.align = "center", figure.height = 5, figure.width = 5}

# set the url
url <- "https://cjrc.la.psu.edu/wp-content/uploads/sites/21/2020/10/PINS-Get-Along-With-Edgelist.csv"

# read in the edgelist
GA.edgelist <- read.csv(url,header=FALSE,as.is=TRUE)

# create the network using the matrix.type= argument
GA.net <- as.network(GA.edgelist,directed=TRUE, matrix.type="edgelist")

# note that the network contains 9 isolates
length( which( has.edges( GA.net ) == FALSE ) )

# We can remove these by using the get.inducedSubgraph() function.
# Specifically, we stipulate in the v= argument that we only want vertices that have edges incident on them.
GA.net <- get.inducedSubgraph(GA.net, v=which(has.edges(GA.net) ==TRUE))

# Now, take a look at the plot.
gplot(GA.net, edge.col="grey40", vertex.col="lightgreen", main="PINS Get Along With Network")
```

#### *What are the features of the network that "jump-out" when you examine the plot?*   


***  

#### ***Questions?***


<br>

##### ***Please*** report any needed corrections to the [Issues](https://github.com/jacobtnyoung/SAND/issues/new) page. Thanks!

<br>
<br>


###### ***Last updated `r format(Sys.time(), '%d %B, %Y')`***